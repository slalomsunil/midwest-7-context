#!/bin/bash

set -e

# We assume the things we're installing are relative to this script
# and that we're being run from a git repo
SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
REPO_ROOT=$(git rev-parse --show-toplevel)
GITIGNORE="$REPO_ROOT/.gitignore"

# Default values
USE_SYMLINK=false

# Shared exclude patterns
EXCLUDE_PATTERNS=("install.sh" "*.template.md")

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --symlink)
      USE_SYMLINK=true
      shift
      ;;
    *)
      echo "Unknown option: $1"
      echo "Usage: $0 [--symlink]"
      echo "  --symlink    Use symlinks instead of copying files"
      exit 1
      ;;
  esac
done

# Add gitignore rule
echo -e "\n\033[34mInstalling\033[0m gitignore pattern..."
if ! grep -q "^ai-scratch-\*" "$GITIGNORE" 2>/dev/null; then
  # Add the pattern with a descriptive comment
  # If file doesn't exist, it will be created
  {
    [[ -f "$GITIGNORE" ]] && echo ""  # Add blank line if file exists
    echo "# AI scratch workspaces (generated by scratch-management-utilities)"
    echo "ai-scratch-*"
  } >> "$GITIGNORE"
  echo "  Added ai-scratch-* to .gitignore"
else
  echo "  ai-scratch-* already in .gitignore ✅"
fi

echo -e "\n\033[34mChecking\033[0m for existing files..."

# Check for existing files
EXISTING_FILES=()

# Check both commands and lib/scratch-management directories with a single loop
for file in "$REPO_ROOT/.claude/"{commands,lib/scratch-management}/*.md; do
  if [[ -e "$file" ]]; then
    EXISTING_FILES+=("$file")
  fi
done

# If files exist, ask for confirmation
if [[ ${#EXISTING_FILES[@]} -gt 0 ]]; then
  echo -e "\n\033[33m⚠️  Found \033[5mexisting\033[25m files in .claude directory:\033[0m"
  for file in "${EXISTING_FILES[@]}"; do
    # Show relative path from repo root for cleaner output
    relative_path="${file#"$REPO_ROOT/"}"
    echo "  - $relative_path"
  done
  echo ""
  # Red color for the warning prompt
  echo -en "\033[31mOverwrite existing files? (y/N): \033[0m"
  while true; do
    read -n 1 -s -r  # -s for silent (no echo)
    # Accept only y/Y/n/N or Enter (empty)
    if [[ -z "$REPLY" || "$REPLY" =~ ^[yYnN]$ ]]; then
      echo "$REPLY"  # Echo the valid response
      break
    fi
    # For escape sequences, consume remaining bytes silently
    if [[ "$REPLY" == $'\033' ]]; then
      read -n 2 -s -t 1  # Consume [A or similar
    fi
  done
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Installation cancelled"
    exit 0
  fi
fi

# Install based on mode
if [[ "$USE_SYMLINK" == "true" ]]; then
  echo -e "\033[34mInstalling\033[0m with symlinks..."

  # Find all .md files in the source directory and create symlinks
  find "$SCRIPT_DIR" -name "*.md" -type f | while read -r file; do
    filename=$(basename "$file")

    # Skip excluded patterns
    skip=false
    for pattern in "${EXCLUDE_PATTERNS[@]}"; do
      if [[ "$filename" == $pattern ]]; then
        skip=true
        break
      fi
    done

    if [[ "$skip" == "true" ]]; then
      continue
    fi

    # Get the directory path relative to SCRIPT_DIR
    rel_path="${file#"$SCRIPT_DIR/"}"
    dir_path=$(dirname "$rel_path")

    # Create the target directory if needed and create symlink
    target_dir="$REPO_ROOT/.claude/$dir_path"
    mkdir -p "$target_dir"
    ln -sf "$file" "$target_dir/$filename"

    # Show relative path for cleaner output
    if [[ "$dir_path" == "." ]]; then
      echo -e "  \033[32mLinked:\033[0m $filename"
    else
      echo -e "  \033[32mLinked:\033[0m $dir_path/$filename"
    fi
  done
else
  echo "Using rsync mode"
  # Build exclude arguments for rsync from shared patterns
  RSYNC_ARGS=(-avv)
  for pattern in "${EXCLUDE_PATTERNS[@]}"; do
    RSYNC_ARGS+=("--exclude=$pattern")
  done

  # Now, copy files.
  # we use rsync because we're cool like that
  rsync "${RSYNC_ARGS[@]}" "${SCRIPT_DIR}/" "${REPO_ROOT}/.claude/"
fi

# Report which mode was used
echo -e "\n\033[32mInstallation complete using $([[ "$USE_SYMLINK" == "true" ]] && echo "symlink" || echo "rsync") mode!!\033[0m"